# -*- coding: utf-8 -*-
"""sales forecasting forecast.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17yYjmthCbrgmJml99sfpRZmzc7RAQV2o
"""

!pip install pandas sqlalchemy pmdarima prophet

"""**Mount Google Drive**

**Install Necessary Libraries**
"""

from google.colab import drive
drive.mount('/content/drive')

"""**Load the Rossmann Store Sales Dataset**

"""

# Load dataset
df = pd.read_csv('/content/drive/MyDrive/LGPS internship project/rossmann-store-sales/train.csv')
df['Date'] = pd.to_datetime(df['Date'])

"""**Import Libraries**"""

import sqlite3
import pandas as pd
from sqlalchemy import create_engine
import matplotlib.pyplot as plt
from pmdarima import auto_arima
from prophet import Prophet

print(df.columns)

print(df.head())

df.rename(columns={'incorrect_column_name': 'date'}, inplace=True)

# Check the columns
print(df.columns)

# Check the first few rows of the DataFrame
print(df.head())

# Rename columns if necessary
df.rename(columns={'incorrect_column_name_store': 'store', 'incorrect_column_name_sales': 'sales'}, inplace=True)

# Fetch data for a specific store (e.g., Store 1)
store_id = 1
df_store = df[df['Store'] == store_id]
df_store = df_store[['Date', 'Sales']]
df_store = df_store[df_store['Sales'] > 0]

# Ensure the date column is in datetime format
df_store['Date'] = pd.to_datetime(df_store['Date'])

# Set the date column as the index
df_store.set_index('Date', inplace=True)

# Sort the data by date
df_store.sort_index(inplace=True)

# Perform seasonal decomposition
result = seasonal_decompose(df_store['Sales'], model='multiplicative', period=365)

# Plot the decomposed components
fig, (ax1, ax2, ax3, ax4) = plt.subplots(4, 1, figsize=(15, 12))
result.observed.plot(ax=ax1)
ax1.set_ylabel('Observed')
result.trend.plot(ax=ax2)
ax2.set_ylabel('Trend')
result.seasonal.plot(ax=ax3)
ax3.set_ylabel('Seasonal')
result.resid.plot(ax=ax4)
ax4.set_ylabel('Residual')
plt.show()

"""**Create SQLite Database and Table**"""

# Connect to SQLite database (or create it if it doesn't exist)
conn = sqlite3.connect('retail_sales.db')
cursor = conn.cursor()

# Create sales_data table
cursor.execute('''
CREATE TABLE IF NOT EXISTS sales_data (
    Store INTEGER,
    Date TEXT NOT NULL,
    Sales REAL NOT NULL,
    PRIMARY KEY (Store, Date)
)
''')
conn.commit()

# Insert data into the database
df.to_sql('sales_data', conn, if_exists='replace', index=False)

"""**Fetch Data from Database and Preprocess**
Fetch Data Using Pandas
"""

# Fetch data for a specific store (e.g., Store 1)
store_id = 1
query = f"SELECT Date, Sales FROM sales_data WHERE Store = {store_id} AND Sales > 0"
df_store = pd.read_sql(query, conn)

"""***Step 5: Implement Time Series Forecasting Model Using ARIMA ***"""

# Fit ARIMA model
model = auto_arima(df_store['Sales'], seasonal=True, m=12, error_action='ignore', suppress_warnings=True)
print(model.summary())

"""**Forecast Future Sales**"""

# Forecast for the next 30 days
forecast, conf_int = model.predict(n_periods=30, return_conf_int=True)

# Create a DataFrame with the forecast results
forecast_dates = pd.date_range(start=df_store.index[-1], periods=30+1, inclusive='right')
forecast_df = pd.DataFrame({'Date': forecast_dates, 'Forecast': forecast})

# Plot the forecast
plt.figure(figsize=(10, 6))
plt.plot(df_store.index, df_store['Sales'], label='Historical Sales')
plt.plot(forecast_df['Date'], forecast_df['Forecast'], label='Forecast', color='red')
plt.fill_between(forecast_df['Date'], conf_int[:, 0], conf_int[:, 1], color='red', alpha=0.3)
plt.xlabel('Date')
plt.ylabel('Sales')
plt.title('Sales Forecast using ARIMA')
plt.legend()
plt.show()

"""**Store ARIMA Forecast in the Database**"""

# Store ARIMA Forecast
forecast_df['Forecast'] = forecast_df['Forecast'].round(2)
forecast_df.to_sql('forecast_data', conn, if_exists='replace', index=False)

"""**Fit Prophet Model**"""

# Prophet requires a specific format
df_prophet = df_store.reset_index().rename(columns={'Date': 'ds', 'Sales': 'y'})

# Fit the model
model = Prophet()
model.fit(df_prophet)

"""**Forecast Future Sales**"""

# Make a future dataframe for the next 30 days
future = model.make_future_dataframe(periods=30)

# Predict
forecast = model.predict(future)

# Plot the forecast
fig = model.plot(forecast)
plt.title('Sales Forecast using Prophet')
plt.xlabel('Date')
plt.ylabel('Sales')
plt.show()

"""**Store Prophet Forecast**"""

# Select relevant columns from Prophet forecast
prophet_forecast_df = forecast[['ds', 'yhat']].rename(columns={'ds': 'Date', 'yhat': 'Forecast'})
prophet_forecast_df['Forecast'] = prophet_forecast_df['Forecast'].round(2)
prophet_forecast_df.to_sql('prophet_forecast_data', conn, if_exists='replace', index=False)

# Create a connection to the SQLite database
engine = create_engine('sqlite:///retail_sales.db', echo=False)

# Plot the decomposed components and the Prophet forecast
fig, axes = plt.subplots(5, 1, figsize=(15, 18))

# Seasonal Decomposition plots
result.observed.plot(ax=axes[0])
axes[0].set_ylabel('Observed')
axes[0].set_title('Seasonal Decomposition of Sales Data')

result.trend.plot(ax=axes[1])
axes[1].set_ylabel('Trend')

result.seasonal.plot(ax=axes[2])
axes[2].set_ylabel('Seasonal')

result.resid.plot(ax=axes[3])
axes[3].set_ylabel('Residual')

# Prophet forecast plot
axes[4].plot(df_prophet['ds'], df_prophet['y'], label='Historical Sales')
axes[4].plot(prophet_forecast_df['Date'], prophet_forecast_df['Forecast'], label='Forecast', color='red')
axes[4].set_xlabel('Date')
axes[4].set_ylabel('Sales')
axes[4].set_title('Sales Forecast using Prophet')
axes[4].legend()

plt.tight_layout()
plt.show()

!pip install pandas matplotlib seaborn plotly

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px
from prophet import Prophet
from sqlalchemy import create_engine
from statsmodels.tsa.seasonal import seasonal_decompose

# Example interactive plot with Plotly (adjust based on your data)
fig = px.line(df_store, x=df_store.index, y='Sales', title='Sales Over Time')
fig.show()

# Create a dashboard-style layout with subplots
fig, axes = plt.subplots(3, 1, figsize=(12, 18))

# Plot seasonal decomposition
axes[0].plot(result.observed, label='Observed')
axes[0].legend()

axes[1].plot(result.trend, label='Trend')
axes[1].legend()

axes[2].plot(result.seasonal, label='Seasonal')
axes[2].legend()

plt.tight_layout()
plt.show()

!pip install dash plotly

# Import necessary Dash libraries
import dash
import dash_core_components as dcc
import dash_html_components as html
import plotly.graph_objs as go

# Initialize the Dash app
app = dash.Dash(__name__)

# Initialize the Dash app
app = dash.Dash(__name__)

# Define the layout of the dashboard
app.layout = html.Div([
    html.H1('Sales Analysis Dashboard'),

    # Seasonal Decomposition Plot
    dcc.Graph(
        id='seasonal-decomposition',
        figure={
            'data': [
                {'x': result.observed.index, 'y': result.observed, 'type': 'line', 'name': 'Observed'},
                {'x': result.trend.index, 'y': result.trend, 'type': 'line', 'name': 'Trend'},
                {'x': result.seasonal.index, 'y': result.seasonal, 'type': 'line', 'name': 'Seasonal'},
                {'x': result.resid.index, 'y': result.resid, 'type': 'line', 'name': 'Residual'}
            ],
            'layout': {
                'title': 'Seasonal Decomposition of Sales Data'
            }
        }
    ),

    # Prophet Forecast Plot
    dcc.Graph(
        id='prophet-forecast',
        figure={
            'data': [
                {'x': df_prophet['ds'], 'y': df_prophet['y'], 'type': 'line', 'name': 'Historical Sales'},
                {'x': prophet_forecast_df['Date'], 'y': prophet_forecast_df['Forecast'], 'type': 'line', 'name': 'Forecast'}
            ],
            'layout': {
                'title': 'Sales Forecast using Prophet',
                'xaxis': {'title': 'Date'},
                'yaxis': {'title': 'Sales'}
            }
        }
    )
])

# Run the app
if __name__ == '__main__':
    app.run_server(debug=True)

import numpy as np  # Import NumPy

import seaborn as sns

# Example data for histogram
data = np.random.normal(loc=0, scale=1, size=1000)

# Plotting histogram using seaborn
plt.figure(figsize=(8, 6))  # Adjust figsize as needed
sns.histplot(data, bins=20, kde=True)
plt.title('Histogram of Data')
plt.xlabel('Value')
plt.ylabel('Frequency')
plt.show()

# Example data for pie chart
labels = ['Category A', 'Category B', 'Category C']
sizes = [30, 40, 30]

# Plotting pie chart using matplotlib
plt.figure(figsize=(6, 6))  # Square figsize
plt.pie(sizes, labels=labels, autopct='%1.1f%%', startangle=140)
plt.title('Pie Chart of Data')
plt.show()

import matplotlib.pyplot as plt

# Example: Line plot of sales over time
plt.figure(figsize=(12, 6))
plt.plot(df['Date'], df['Sales'], marker='o', linestyle='-', color='b')
plt.title('Sales Over Time')
plt.xlabel('Date')
plt.ylabel('Sales')
plt.grid(True)
plt.show()

# Example: Scatter plot of Sales vs Customers
plt.figure(figsize=(8, 6))
plt.scatter(df['Customers'], df['Sales'], color='r', marker='o', s=30, alpha=0.5)
plt.title('Scatter Plot: Sales vs Customers')
plt.xlabel('Customers')
plt.ylabel('Sales')
plt.grid(True)
plt.show()

# Example: Histogram of Sales
plt.figure(figsize=(8, 6))
plt.hist(df['Sales'], bins=20, edgecolor='black')
plt.title('Histogram of Sales')
plt.xlabel('Sales Amount')
plt.ylabel('Frequency')
plt.grid(axis='y')
plt.show()